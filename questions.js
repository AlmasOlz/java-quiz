const allTests = {
java: [
    {
            question: "Бірөлшемді массивті қалай жариялайды?",
            options: ["int[] arr = new int[5];", "int array[5];", "array arr;", "new int array[5];", "arr = int[5];"],
            correct: 0
        },
        {
            question: "Көпөлшемді массивтер қай жерде қолданылады?",
            options: ["Матрицалар, кестелер және графтар үшін", "Қарапайым сандарды сақтау үшін", "Тек String ішінде", "Бір ғана мәнді сақтау үшін", "Логикалық операцияларда"],
            correct: 0
        },
        {
            question: "Массивтің максималды элементін қалай табуға болады?",
            options: ["Элементтерді цикл арқылы салыстыру арқылы", "max() операторын қолдану", "if-else көмегімен", "print() функциясын қолдану", "Конструктор арқылы"],
            correct: 0
        },
        {
            question: "Массив пен ArrayList айырмашылығы қандай?",
            options: ["ArrayList динамикалық", "ArrayList өлшемі тұрақты", "Массив динамикалық өзгереді", "Екеуі бірдей", "Массив жылдамырақ"],
            correct: 0
        },
        {
            question: "Java тілінде екі матрицаны қалай қосады?",
            options: ["Ішкі циклдер арқылы", "+ операторымен", "Массив арқылы қолмен", "sum() функциясы арқылы", "Scanner класы арқылы"],
            correct: 0
        },
        {
            question: "Класс деген не?",
            options: ["Объектілерді жасауға арналған үлгі", "Жадтағы объект", "Айнымалы", "Цикл операторы", "Константа"],
            correct: 0
        },
        {
            question: "Объект қалай жасалады?",
            options: ["new Класс();", "create Класс();", "object Класс;", "init Класс();", "make Класс();"],
            correct: 0
        },
        {
            question: "Конструктор деген не?",
            options: ["Арнайы әдіс (Объектіні инициализациялау үшін)", "Класты жасау әдісі", "Объектіні жою әдісі", "Компиляцияға арналған функция", "Әдістің параметрі"],
            correct: 0
        },
        {
            question: "Пакеттердің мақсаты қандай?",
            options: ["Кластарды топтастыру және жобаның құрылымын ұйымдастыру үшін", "Шығару форматтау үшін", "Сандарды сақтау үшін", "Деректерді бөлек файлдарға қайта құрылымдау үшін", "Түзету (отладка) үшін"],
            correct: 0
        },
        {
            question: "this кілттік сөзі қалай жұмыс істейді?",
            options: ["Ағымдағы объектіге сілтеме жасайды", "Мұрагерлікке қолданылады", "Ата-аналық классты көрсетеді", "Бағдарлама соңын білдіреді", "Интерфейсте қолданылады"],
            correct: 0
        },
        {
            question: "Getter және Setter әдістерінің айырмашылығы неде?",
            options: ["Getter мәнді қайтарады, Setter өзгертеді", "Getter өзгертеді, Setter қайтарады", "Getter есептеулер жасайды", "Setter объект жасайды", "Setter өрісті өшіреді"],
            correct: 0
        },
        {
            question: "Инкапсуляция деген не?",
            options: ["Деректерді жасыру", "Кластарды мұрагерлеу", "Көптік қайта анықтау", "Интерфейстер жасау", "Массивтерді қолдану"],
            correct: 0
        },
        {
            question: "Мұрагерлікке мысал келтіріңіз.",
            options: ["class A extends B {}", "class A implements B {}", "class A : B", "class A(B):", "class A inherit B"],
            correct: 0
        },
        {
            question: "Полиморфизм деген не?",
            options: ["Объектінің бірнеше форма қабылдау мүмкіндігі", "Кластарды қайталау", "Көптік мұрагерлік", "Әр түрлі деректер үшін класс атын бірдей ету", "Ағындармен жұмыс"],
            correct: 0
        },
        {
            question: "@Override аннотациясы не үшін қолданылады?",
            options: ["Әдісті қайта анықтауды белгілеу үшін", "Конструкторды жариялау үшін", "Интерфейс жасау үшін", "Пакетті жариялау үшін", "Әдістерді қайта жүктеуді белгілеу үшін"],
            correct: 0
        },
        {
            question: "super кілттік сөзінің рөлі қандай?",
            options: ["Ата-аналық класстың әдістеріне қол жеткізу", "Жаңа объект жасау үшін", "Конструкторды шақыру үшін", "Файлдағы басты класты көрсету", "Жеке (private) өрістерге қол жеткізу үшін"],
            correct: 0
        },
        {
            question: "Абстракция мен инкапсуляцияның айырмашылығы қандай?",
            options: ["Абстракция — іске асыруды, инкапсуляция — деректерді жасырады", "Абстракция — бұл мұрагерлік", "Дұрыс жауап жоқ", "Абстракция интерфейстерге тыйым салады, инкапсуляция кодты жария етеді", "Екеуі бірдей"],
            correct: 0
        },
        {
            question: "Сыртқы класс деген не?",
            options: ["Бір кластың ішінде орналасқан статикалық класс", "Басқа пакетте орналасқан класс", "Абстракт класс", "Статикалық әдіс", "Басқа кластың ішінде жарияланған класс"],
            correct: 0
        },
        {
            question: "Анонимді класс қашан қолданылады?",
            options: ["Интерфейстің бір реттік жүзеге асыруы қажет болғанда", "Бірнеше класты мұрагерлеу керек болғанда", "Массивтерді сипаттау үшін", "Деректерді сақтау үшін", "Тестілеу үшін"],
            correct: 0
        },
        {
            question: "Интерфейс пен класс айырмашылығы неде?",
            options: ["Интерфейс тек әрекеттерді анықтайды", "Интерфейс жүзеге асыруды қамтуы мүмкін", "Класс интерфейсті мұрагерлей алмайды", "Интерфейс объекттер жасайды", "Класс пен интерфейс бірдей"],
            correct: 0
        },
        {
            question: "Абстракт класс пен интерфейстің айырмашылығы қандай?",
            options: ["Интерфейс әдістердің жүзеге асырылуын қамти алмайды", "Абстракт класс конструктор қамти алмайды", "Абстракт класты мұрагерлеуге болмайды", "Интерфейс тек Object-тен ғана мұрагерленеді", "Интерфейс тек айнымалыларды қамтиды"],
            correct: 0
        },
        {
            question: "Java-да қандай аннотациялар бар?",
            options: ["@Override, @Deprecated, @SuppressWarnings", "@Public, @Private, @Hidden", "@Loop, @Static, @Else", "@If, @Return, @Try", "@Main, @Print, @Data"],
            correct: 0
        },
        {
            question: "Интерфейсті жүзеге асыруға мысал келтіріңіз.",
            options: ["class A implements B {}", "class A extends B {}", "interface A extends B {}", "class A inherit B {}", "class A interface B {}"],
            correct: 0
        },
        {
            question: "String класының негізгі әдістері қандай?",
            options: ["length(), substring(), concat()", "add(), remove(), insert(), equals()", "next(), hasNext(), clear()", "append(), replaceAll(), get()", "shift(), splitAt(), joinAt()"],
            correct: 0
        },
        {
            question: "StringBuilder мен StringBuffer айырмашылығы қандай?",
            options: ["StringBuffer синхрондалған, StringBuilder — синхрондалмаған", "StringBuilder синхрондалған, StringBuffer — синхрондалмаған", "Екеуі де синхрондалған", "Екеуі де өзгермейтін", "StringBuilder тек ағындармен жұмыс істейді"],
            correct: 0
        },
        {
            question: "try-catch-finally қалай жұмыс істейді?",
            options: ["Қателерді өңдеу үшін", "Әдістерді жариялау үшін", "Циклдерді ұйымдастыру үшін", "Кластарды импорттау үшін", "Мұрагерлік үшін"],
            correct: 0
        },
        {
            question: "throw мен throws айырмашылығы қандай?",
            options: ["throw — қате тастау үшін, throws — оны жариялау үшін", "Барлық жауаптар дұрыс", "throws қате тастайды, throw жариялайды", "Екеуі де бірдей", "Екеуі де әдістерді жариялайды"],
            correct: 0
        },
        {
            question: "Өзінің ерекше жағдайын (exception) қалай жасауға болады?",
            options: ["Exception класынан мұрагерлеу", "Object класын қолдану", "catch операторы арқылы", "final арқылы", "error() әдісі арқылы"],
            correct: 0
        },
        {
            question: "NullPointerException қашан пайда болады?",
            options: ["null-сілтемеге жүгінгенде", "Нөлге бөлгенде", "Деректер түрі дұрыс емес кезде", "Бағдарлама аяқталғанда", "Жад толғанда"],
            correct: 0
        },
        {
            question: "File класы не үшін қолданылады?",
            options: ["Файлдар және директориялармен жұмыс үшін", "Арифметика үшін", "Шифрлау үшін", "Интерфейстер үшін", "Ағындар үшін"],
            correct: 0
        },
        {
            question: "Scanner арқылы файлды қалай оқу керек?",
            options: ["new Scanner(file)", "File.read()", "Scanner.get(file)", "file.readScanner()", "scan(file).read()"],
            correct: 0
        },
        {
            question: "FileWriter арқылы файлға жазу мысалы.",
            options: ["FileWriter fw = new FileWriter(\"file.txt\"); fw.write(\"text\");", "FileWriter(\"file.txt\").print(\"text\");", "Writer.add(\"file.txt\");", "File.save(\"text\");", "file.print(\"text\");"],
            correct: 0
        },
        {
            question: "InputStream және OutputStream айырмашылығы қандай?",
            options: ["InputStream — оқу үшін, OutputStream — жазу үшін", "Екеуі де оқу үшін", "InputStream — жазу үшін, OutputStream — оқу үшін", "InputStream жолдар үшін, OutputStream сандар үшін", "Екеуі бірдей"],
            correct: 0
        },
        {
            question: "BufferedReader артықшылығы қандай?",
            options: ["Жылдам жол-жолымен оқу", "Файлды автоматты жабу", "FileWriter-ды алмастырады", "Жазу үшін қолданылады", "Тек XML үшін жұмыс істейді"],
            correct: 0
        },
        {
            question: "try-with-resources не үшін қолданылады?",
            options: ["Ресурстарды автоматты түрде жабу үшін", "Көпағындылық үшін", "Циклдер үшін", "Мұрагерлік үшін", "Қате деректерді өңдеу үшін"],
            correct: 0
        },
        {
            question: "Collection интерфейсінің мақсаты қандай?",
            options: ["Барлық коллекциялар үшін базалық интерфейс", "Файлдармен жұмыс интерфейсі", "Жолдар (string) үшін интерфейс", "Ағындар үшін", "Ерекше жағдайлар үшін"],
            correct: 0
        },
        {
            question: "List интерфейсінің ерекшеліктері қандай?",
            options: ["Элементтер реттелген және индекс арқылы қолжетімді", "Дубликаттарға жол бермейді", "Ретсіз", "Тек бірегей кілттер", "null сақтамайды"],
            correct: 0
        },
        {
            question: "Set қай кезде қолданылады?",
            options: ["Дубликаттарға жол бермейді", "Индекстер керек болғанда", "Ретті сақтау үшін", "Деректер енгізу үшін", "Файлдарды оқу үшін"],
            correct: 0
        },
        {
            question: "Map деректерді кілт-мән ретінде қалай сақтайды?",
            options: ["(кілт, мән) жұбы", "Тек мәндер", "Бірегей тізім", "Ретсіз", "Тізім ретінде"],
            correct: 0
        },
        {
            question: "Queue интерфейсінің рөлі қандай?",
            options: ["FIFO принципімен сақтау", "Коллекцияларды сұрыптау", "Кілт-мән жұптарын сақтау", "Қателерді өңдеу", "Деректер енгізу"],
            correct: 0
        },
        {
            question: "ArrayList және LinkedList айырмашылығы?",
            options: ["ArrayList элементтерді массивте, LinkedList — тізбек түйіндерінде сақтайды", "Дұрыс жауап жоқ", "ArrayList дубликаттарды қабылдамайды, LinkedList индексте жылдам", "LinkedList итераторларды қолдамайды", "Екеуі бірдей"],
            correct: 0
        },
        {
            question: "HashMap және TreeMap айырмашылығы?",
            options: ["HashMap сұрыптамайды, TreeMap — сұрыптайды", "TreeMap HashMap-тан жылдамырақ", "HashMap null-кілттерге рұқсат етеді, TreeMap — жоқ", "TreeMap итерацияны қолдамайды", "Екеуі де элементтерді бірдей түрде сұрыптайды"],
            correct: 0
        },
        {
            question: "Стек қандай әдістерге ие?",
            options: ["push, pop, peek", "offer, poll, add, empty", "add, push, search", "push, poll, peek", "empty, search, offer"],
            correct: 0
        },
        {
            question: "Writer әдісі осы классқа жүгінбейтін қай әдіс?",
            options: ["commit", "flush", "write", "close", "writeline"],
            correct: 0
        },
        {
            question: "Деректерді қосымшада қалай ұйымдастырып сақтау керек?",
            options: ["Файлдар, дерекқорлар немесе коллекциялар арқылы", "Тек айнымалылар арқылы", "Константалар арқылы", "GUI арқылы", "Тек файл арқылы"],
            correct: 0
        },
        {
            question: "Weka кітапханасы қандай мүмкіндіктер береді?",
            options: ["Машиналық оқыту және деректерді талдау құралдары", "Графиктерді салу үшін", "Жадты оңтайландыру үшін", "UI тестілеу үшін", "Дайын деректерді болжау үшін"],
            correct: 0
        },
        {
            question: "Smile кітапханасының рөлі қандай?",
            options: ["Машиналық оқыту және деректерді визуализациялау үшін", "Ағындармен жұмыс жасау үшін", "Желілік қосылымдар үшін", "Файлдарды оқу үшін", "GUI үшін жұмыс істеу үшін"],
            correct: 0
        },
        {
            question: "Java тілінде деректерді визуализациялау құралдары қандай?",
            options: ["барлық жауаптар дұрыс", "JavaFX Charts", "JFreeChart", "OpenCV", "Smile Plot"],
            correct: 0
        },
        {
            question: "Деректерді нормализациялау дегеніміз не?",
            options: ["Деректерді бірдей масштабқа келтіру", "Деректерді кездейсоқ өзгерту", "Деректерді жою", "Деректерді пакеттерге бөлу", "Жолдарды араластыру"],
            correct: 0
        },
        {
            question: "Алдын ала деректерді түрлендіру не үшін қажет?",
            options: ["Модельдердің дәлдігін арттыру үшін", "Компиляцияны жылдамдату үшін", "Қателерді тексеру үшін", "Тілді өзгерту үшін", "Кодты қысқарту үшін"],
            correct: 0
        },
        {
            question: "Supervised learning мысалына мысал келтіріңіз.",
            options: ["Хаттарды «спам» және «спам емес» деп классификациялау", "Клиенттерді кластерлеу", "Суреттерді генерациялау", "Видеоны сегментациялау", "Шулы деректерді жою"],
            correct: 0
        },
        {
            question: "Unsupervised learning деген не?",
            options: ["Алдын ала белгіленбеген деректермен оқыту", "Мұғаліммен оқыту", "Код генерациялау", "GUI-мен жұмыс", "Модельдерді тестілеу"],
            correct: 0
        },
        {
            question: "Классификация мен кластерлеудің айырмашылығы неде?",
            options: ["Классификация белгіленген деректерді қолданады, кластерлеу — қолданбайды", "Кластерлеу мұғалімді қолданады", "Екеуі де supervised", "Екеуі де белгілерді қажет етеді", "Классификация — кездейсоқ бөлу"],
            correct: 0
        },
        {
            question: "Нейрондық желі дегеніміз не?",
            options: ["Адам миының жұмысын модельдейтін математикалық модель", "Сұрыптау алгоритмі", "Дерекқор жүйесі", "Шифрлау әдісі", "Графикалық интерфейс"],
            correct: 0
        },
        {
            question: "DL4J фреймворкі не үшін қолданылады?",
            options: ["Java тілінде нейрондық желілерді құру және үйрету үшін", "Дерекқорлармен жұмыс істеу үшін", "GUI құру үшін", "Бағдарламаларды компиляциялау үшін", "Деректерді шифрлау үшін"],
            correct: 0
        },
        {
            question: "CNN қандай міндеттерде қолданылады?",
            options: ["Суреттерді өңдеу үшін", "Мәтіндерді талдау үшін", "Уақыттық қатарлармен жұмыс үшін", "Дыбыстарды классификациялау үшін", "Ағындарды басқару үшін"],
            correct: 0
        },
        {
            question: "RNN қай жағдайда қолданылады?",
            options: ["Реттілікті қажет ететін деректерді талдау үшін", "Суреттермен жұмыс істеу үшін", "Дерекқордағы есептеулер үшін", "Сандарды сұрыптау үшін", "Визуализация үшін"],
            correct: 0
        },
        {
            question: "Активтендіру функциясы дегеніміз не?",
            options: ["Нейронның шығыс мәнін анықтайтын математикалық функция", "Лог жүргізу құралы", "Сериализация әдісі", "Деректер ағыны", "Класс конструкторы"],
            correct: 0
        },
        {
            question: "AI-жобасын іске асыру кезеңдері қандай?",
            options: ["Деректерді жинау, өңдеу, модельді оқыту, тестілеу, енгізу", "Интерфейс жазу", "Статистика жинау", "Дерекқор құру", "Тек модельді оқыту"],
            correct: 0
        },
        {
            question: "Java тілінде суретті тану кітапханалары қандай?",
            options: ["OpenCV", "JUnit, Mockito", "Apache Commons", "JDBC", "JSoup"],
            correct: 0
        },
        {
            question: "Transfer Learning дегеніміз не?",
            options: ["Алдын ала дайын оқытылған модельді жаңа тапсырмаға қолдану", "Ағындар арасында деректерді беру", "Модельді сериализациялау", "Файлдарды тасымалдау", "Кластарды пакеттер арасында көшіру"],
            correct: 0
        },
        {
            question: "Java-файл атауына қойылатын талап қандай?",
            options: ["Файл атауы public модификаторлы класс атауымен сәйкес болуы керек", "Файл кез келген атаумен сақталуы мүмкін", "Файл бірінші әдістің атымен аталуы керек", "Файл міндетті түрде Main.java деп аталу керек", "Файл атауы пакет атауымен бірдей болуы қажет"],
            correct: 0
        },
        {
            question: "Терминалда Java-класты компиляциялау және іске қосу реттілігі?",
            options: ["javac MyClass.java, содан кейін java MyClass", "run MyClass.java", "java MyClass.java", "javac MyClass, содан кейін run MyClass", "java compile MyClass"],
            correct: 0
        },
        {
            question: "Classpath дегеніміз не?",
            options: ["JVM кластар мен кітапханаларды іздейтін жол", "Жүйелік айнымалылар жолы", "Java бастапқы кодтары жолы", "JVM орындалатын файлының жолы", "Жоба конфигурация файлдарының жолы"],
            correct: 0
        },
        {
            question: "Classpath-та екі бірдей кітапхана болса, қайсысы қолданылады?",
            options: ["JVM бірінші тапқанын қолданады", "Екі кітапхана қатар қолданылады", "Classpath соңғы тұрғаны қолданылады", "Кездейсоқ таңдалады", "JVM қате шығарады"],
            correct: 0
        },
        {
            question: "Объектпен объект сілтемесінің айырмашылығы неде?",
            options: ["Объект — бұл жад аймағы, ал сілтеме — оған нұсқайтын айнымалы", "Айырмашылық жоқ", "Жауабы жоқ", "Объект — сілтеме, сілтеме — объект көшірмесі", "Сілтеме объектінің өзін сақтайды"],
            correct: 0
        },
        {
            question: "Java-да деректер қайда орналасады?",
            options: ["барлық жауап дұрыс", "объектілер — heap-те", "константалар — metadata аймағында", "әдістер — metadata аймағында", "қарапайым типтер — stack-та"],
            correct: 0
        },
        {
            question: "main() әдісі неге public static void ретінде жарияланады?",
            options: ["JVM оны объект құрмай-ақ шақыра алады", "Кодтау стилі солай талап етеді", "Басқа кластардан шақыру үшін", "Бұл интерфейс әдісі болғандықтан", "Компилятор пішім қатесін шығармау үшін"],
            correct: 0
        },
        {
            question: "main() сигнатурасында static және void сөздерінің орнын ауыстыруға бола ма?",
            options: ["Иә, болады — public static void main() және public void static main() бірдей", "Жоқ, реттілігі бекітілген", "Иә, болады — public void static main()", "Егер әдіс public болмаса ғана", "Java 8 дейінгі нұсқаларда ғана"],
            correct: 0
        },
        {
            question: "public немесе static модификаторы болмаса, main() шақырыла ма?",
            options: ["Жоқ, JVM оны шақыра алмайды", "Иә, кез келген жағдайда", "Тек public жоқ болса", "Тек static жоқ болса", "Иә, бірақ ескерту жасайды"],
            correct: 0
        },
        {
            question: "Қай пакеттегі кластары автоматты түрде импортталады?",
            options: ["java.lang", "java.util", "java.io", "java.base", "java.system"],
            correct: 0
        },
        {
            question: "Қай примитивті тип көбірек жад алады?",
            options: ["double", "int", "integer", "long", "string"],
            correct: 0
        },
        {
            question: "Примитивті типтегі айнымалылар әдістерге қалай беріледі?",
            options: ["Мәні бойынша", "Сілтеме бойынша", "Указатель арқылы", "Wrapper арқылы", "Сілтеме стегі арқылы"],
            correct: 0
        },
        {
            question: "Примитивті типтердің өлшемі қандай және ол платформаға тәуелді ме?",
            options: ["Өлшемі тұрақты және платформаға тәуелді емес", "Өлшемі процессор архитектурасына байланысты", "Өлшемі JVM іске қосылған кезде анықталады", "Өлшемін аннотация арқылы өзгертуге болады", "Өлшемі әрдайым 4 байт"],
            correct: 0
        },
        {
            question: "Қай типтер басқа типтерге түрлендірілмейді?",
            options: ["boolean және char", "Барлық сандық типтер", "Тек byte", "Тек double", "Барлық сілтемелік типтер"],
            correct: 0
        },
        {
            question: "Айқын және айқын емес тип түрлендіру деген не?",
            options: ["Айқын емес — автоматты кеңейту, айқын — (тип) көрсету арқылы", "Сілтемелерді түрлендіру", "Тек wrapper арқылы", "Тек объектілер арасында", "Бұл auto-boxing-пен бірдей"],
            correct: 0
        },
        {
            question: "Java-да литералдар дегеніміз не?",
            options: ["Кодта жазылған тұрақты мәндер", "Айнымалылар аттары", "Массивтер", "Әдістерді қайта жүктеу", "Операторлар"],
            correct: 0
        },
        {
            question: "Литералдардың қандай түрлері бар?",
            options: ["барлық жауаптар дұрыс", "сандық", "мәтіндік", "boolean", "жолдық"],
            correct: 0
        },
        {
            question: "Әртүрлі типтермен өрнек есептелгенде (мысалы, int + double) не болады?",
            options: ["Разрядтылығы кіші тип үлкен типке түрленеді", "Компиляция қателігі", "Нәтиже әрқашан int", "Нәтиже әрқашан double", "Нәтиже әрқашан Object"],
            correct: 0
        },
        {
            question: "Wrapper Classes дегеніміз не?",
            options: ["Примитивтерді объектке инкапсуляциялайтын кластар", "Коллекциялар интерфейстері", "Object-тен мұра алған кластар", "Лог жүргізу үшін кластар", "Абстрактілі деректер типтері"],
            correct: 0
        },
        {
            question: "Объект-оболочка неліктен константты болып саналады?",
            options: ["Жасалғаннан кейін оның мәні өзгермейді", "Өзгертуге болады", "Ол статикалық", "final ретінде қолдануға болады", "Тек new арқылы жасалады"],
            correct: 0
        },
        {
            question: "Примитивті типтер?",
            options: ["Примитивтер мән сақтайды", "Примитивтер — объект", "Примитивтер — объектінің адрестері", "Примитивтер баяу", "Примитивтерді әдістерге беру"],
            correct: 0
        },
        {
            question: "Сілтемелік тип параметрлері әдістерге қалай беріледі?",
            options: ["Сілтеменің мәні арқылы, яғни сілтеменің көшірмесі беріледі", "Сілтеме мәні арқылы (адрес көшіреді)", "Объект мәні арқылы", "Мазмұн көшірмесі арқылы", "C++ сияқты указатель арқылы"],
            correct: 0
        },
        {
            question: "Оператордың приоритеті дегеніміз не?",
            options: ["Өрнек орындау тәртібін анықтайды", "Деректер типін көрсетеді", "Көріну аймағын анықтайды", "Қол жеткізу модификаторын анықтайды", "Әдіс атауы"],
            correct: 0
        },
        {
            question: "Егер өрнекте бірнеше оператор бірдей приоритетке ие болса не болады?",
            options: ["Солдан оңға қарай орындалады (ассоциативтілік бойынша)", "Компиляция қателігі", "Оңнан солға қарай орындалады", "JVM кездейсоқ тәртіп таңдайды", "Тек бірінші оператор орындалады"],
            correct: 0
        },
        {
            question: "NaN мәні нені білдіреді?",
            options: ["Not a Number", "Not a Null", "Negative a Number", "Natural a Number", "Null and None"],
            correct: 0
        },
        {
            question: "Autoboxing және unboxing деген не?",
            options: ["Примитивті объект-оболочкаға және кері автоматты айналдыру", "Жолдарды орау", "Константаларды жасау", "Массивтерді түрлендіру", "int-ті char-ға түрлендіру"],
            correct: 0
        },
        {
            question: "Java-дағы var дегеніміз не?",
            options: ["Компиляция кезінде типі анықталатын жергілікті айнымалы", "Арнайы айнымалы типі", "Орындау кезінде динамикалық тип", "Object үшін псевдоним", "Резервтелген сөз, бірақ қолданылмайды"],
            correct: 0
        },
        {
            question: "Массив элементіне шектен тыс индекспен жүгінсе не болады?",
            options: ["java.lang.ArrayIndexOutOfBoundsException ерекшелігі тасталады", "Компиляция қателігі", "null қайтарады", "Жаңа элемент жасайды", "JVM қайта іске қосылады"],
            correct: 0
        },
        {
            question: "ArrayStoreException қашан пайда болады?",
            options: ["Сілтемелік массивке сәйкес емес типтегі объектті салғанда", "Массивтен тыс шығу әрекетінде", "Нөлге бөлу кезінде", "Массивті жою кезінде", "Массив аты қате болғанда"],
            correct: 0
        },
        {
            question: "Java-дағы екі өлшемді массив дегеніміз не?",
            options: ["Элементтері басқа массивтер болып табылатын массив", "Тұрақты өлшемді кесте", "Жадтағы матрица", "Арнайы Grid объектісі", "LinkedList негізіндегі құрылым"],
            correct: 0
        },
        {
            question: "Екі өлшемді массив int[][] a ішіндегі жолдар санын және жолдағы элементтер санын қалай білуге болады?",
            options: ["a.length — жолдар саны, a[i].length — жолдағы элементтер саны", "a.size() және a.length()", "Тек Stream API арқылы", "Arrays класы арқылы", "Бұл мүмкін емес"],
            correct: 0
        },
        {
            question: "3 элементтен тұратын бірөлшемді int массивін қалай жариялап, инициализация жасауға болады?",
            options: ["int[] arr = {1, 2, 3};", "int[3] arr = new int[];", "arr = [1,2,3]", "int arr = new int[]{1,2,3};", "int arr = [1,2,3];"],
            correct: 0
        },
        {
            question: "instanceof операторының сол жағында null болса қалай жұмыс істейді?",
            options: ["Әрқашан false қайтарады", "true қайтарады", "Ережеден тыс жағдай тудырады", "Оң жақтағы типке байланысты", "Сілтемелерді салыстырады"],
            correct: 0
        },
        {
            question: "Класс және объект деген не?",
            options: ["Класс — үлгі, объект — сол үлгінің экземпляры", "Класс — айнымалы, объект — деректер типі", "Класс — массив, объект — массив элементі", "Класс — функция, объект — оның аргументі", "Класс — объектінің көшірмесі"],
            correct: 0
        },
        {
            question: "Класты жариялау кезінде қандай спецификаторларды қолдануға болады?",
            options: ["public, abstract, final (сонымен қатар әдепкі package-private)", "Тек public", "Тек private", "Тек protected", "Тек package-private"],
            correct: 0
        },
        {
            question: "Конструктор деген не?",
            options: ["Қайтару типі жоқ, аты класс атымен бірдей әдіс", "Кез келген атауы бар әдіс", "Статикалық әдіс", "final әдіс", "Объект қайтаратын әдіс"],
            correct: 0
        },
        {
            question: "Класта қанша конструктор болуы мүмкін?",
            options: ["Қалағанша көп", "Бірден артық емес", "Әрқашан біреу", "Тек үшеу", "JVM-ге байланысты"],
            correct: 0
        },
        {
            question: "Конструктор по умолчанию деген не?",
            options: ["Бос конструктор", "Программист жасаған конструктор", "Параметрлері бар конструктор", "Статикалық конструктор", "final конструктор"],
            correct: 0
        },
        {
            question: "Конструктор ішінде this() не үшін қолданылады?",
            options: ["Ағымдағы кластың басқа конструкторын шақыру үшін", "Статикалық өрісті шақыру үшін", "Класқа сілтеме жасау үшін", "Объектіні жою үшін", "Мұрагерлік үшін"],
            correct: 0
        },
        {
            question: "Статикалық өрістер қашан инициализацияланады?",
            options: ["Класты JVM жүктеген кезде", "Әр объект құрылған сайын", "main орындалғаннан кейін", "Тек компиляция кезінде", "Кез келген әдіс шақырылғаннан кейін"],
            correct: 0
        },
        {
            question: "Экземпляр өрістері қашан инициализацияланады?",
            options: ["Объект құрылған кезде", "Класс жүктелген кезде", "Компиляция кезінде", "Ешқашан", "Объект инициализация блоктарында"],
            correct: 0
        },
        {
            question: "Өрістерге әдепкіде қандай мәндер беріледі?",
            options: ["Типке байланысты: 0, 0.0, false, null, '\\u0000'", "Ешқандай — қате", "Тек null", "Тек 0", "Тек false"],
            correct: 0
        },
        {
            question: "JavaBeans үшін не талап етіледі?",
            options: ["Private өрістер, public getter/setter, параметрсіз конструктор", "Өрістер public болуы керек", "Параметрсіз конструктор міндетті емес", "set/get әдістері қажет емес", "Класс final болуы керек"],
            correct: 0
        },
        {
            question: "Объектілер мен массивтер қайда сақталады?",
            options: ["Heap-те, ал сілтемелер — стекте", "Тек стекте", "Тек CPU регистрінде", "Тек стек пен регистрде", "Әрқашан статикалық аймақта"],
            correct: 0
        }
    ]
};